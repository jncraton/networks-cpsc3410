Cost-effective resource sharing
===============================

---

- Focusing on a packet switched network, we can see that resources (such core links) are constantly being shared
- How do we ensure that shared resources are used fairly?

---

![Multiplexing multiple flows over one link](https://upload.wikimedia.org/wikipedia/commons/thumb/6/6f/Multiplexing_diagram.svg/640px-Multiplexing_diagram.svg.png)

---

![Synchronous Time-division multiplexing (STDM)](https://upload.wikimedia.org/wikipedia/commons/e/e0/Telephony_multiplexer_system.gif)

Frequency division multiplexing
-------------------------------

- Breaks link into subchannels, and used on for each device
- You're familiar with this in TV and radio
- Wifi channels are also an example

Weaknesses
----------

- Both FDM and STDM waste available resources
- Bandwidth is reserved for all hosts, even when they don't need it
- Number of flows must be known in advance

Statistical multiplexing
------------------------

- Link is shared over time
- Data is transmitted from each flow on demand without waiting for hosts with nothing to say
- One flow may only consume the link for a given amount of time

Quality of Service (QoS)
------------------------

- Various algorithms can be chosen to determine who sends on the medium
    - First-in, first-out (FIFO)
    - Flow-based round-robin
    - Much more complex algorithms

Big idea
--------

Statistical multiplexing allows fair sharing of a link

Support for Common Services
===========================

---

We don't merely want to send packets around, we want to provide service that makes it easy to build applications

Channels
--------

- We think of the network as providing *channels* for individual applications to communicate
- Layering is used to create this channel abstraction on top of packet-switched networks

Channel needs
-------------

- Reliability - Do messages need to arrive?
- Privacy - Can others see our messages?
- Ordering - Do messages need to arrive in the order they were sent?

Big idea
--------

Different applications will have different needs, so we need to design different abstractions that work well for them.

Manageability
=============

---

Networks have to be managed and maintained

Common tasks
------------

- Replacing hardware
- Adding hosts
- Troubleshooting issues

Self-healing designs
--------------------

- Allow humans to be removed from the loop, or at least have a less urgent role

Change management
-----------------

- There is often a tension between *feature velocity* and *stability*
- Any time something is changed, there is a chance that it will cause breakages 

1.3 Architecture
================

---

Layering and Protocols
======================

---

What is abstraction?

---

Abstraction is the hiding of implementation details behind an interface

---

Networks have many complex details that we would like to abstract or hide.

---

Layering
--------

- We combine the network communication tasks into **Layers** with well-defined interfaces

---

![Simple layering approach](https://book.systemsapproach.org/_images/f01-08-9780123850591.png)

---

Any given layer may have multiple implementations that implement the same basic services.

---

![Alternate abstractions](https://book.systemsapproach.org/_images/f01-09-9780123850591.png)

Protocols
---------

- The abstract objects making up the layers of the network stack
- Agreement on how communication should take place

Protocol Interfaces
-------------------

- Service interface - Provides interface for use on the local machine
- Peer interface - Determines messaging and communication with the remote host

---

![Protocol interfaces](https://book.systemsapproach.org/_images/f01-10-9780123850591.png)

Protocol Specifications
-----------------------

- Abstract documents that define how communication should work
- Created and maintained by standards bodies (IETF, ISO, etc)

---

![Protocol Graph](https://book.systemsapproach.org/_images/f01-11-9780123850591.png)

---

How do middle layer protocols communicate with one another?

---

Indirectly, via encapsulation.

Encapsulation
-------------

- High-level messages are embedded in lower-level messages
- **Headers** are attached to the **payload** (body) adding layer-specific information

---

![Encapsulation](https://book.systemsapproach.org/_images/f01-12-9780123850591.png)

Layering
--------

- Headers are added as data passes down the stack of host
- Headers are removed as data is process and moves of the stack of the receiver

Key concept
-----------

Lower layers of the stack do not understand the headers from higher layers. They simply treat the information as a raw data payload.

---

Wireshark Example

Models
======

OSI Model
---------

- 7 layer model
- We do not generally use the OSI model directly in real networks, but it is useful as reference and is still widely discussed

OSI Layers
----------

- Application - High-level protocols (HTTP)
- Presentation - Data formatting (endianess, media formats, etc)
- Session - Connecting multiple channels
- Transport - Process-to-process channel
- Network - Routing among nodes in a network
- Data link - Frames
- Physical - Raw bits

Internet Architecture
---------------------

- 4 layer model
- Reflects design of modern Internet
- Descended from ARPANET architecture
- TCP/IP model

---

![Internet Architecture](https://book.systemsapproach.org/_images/f01-15-9780123850591.png)

---

![Internet Protocols](https://book.systemsapproach.org/_images/f01-14-9780123850591.png){height=540px}

Internet Architecture Concepts
------------------------------

1. Does not imply strict layering
2. Wide at the top, narrow in the middle, wide at the bottom
3. New protocols require specs and implementations

1.4 Software
============

Sockets
=======

---

Sockets provide a standard interface from the network to our applications

Socket types
------------

- Stream - provides a virtual circuit
- Datagram - delivers individual packets

Socket Implementation
---------------------

- Independent of network type
- Most typically used with TCP/IP and UDP/IP

---

![Socket States](media/socket-states.png)

Echo server example
-------------------

```python
import socket

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.bind(('0.0.0.0', 2001))
    s.listen()
    conn, addr = s.accept()
    with conn:
        print('Connected by', addr)
        while True:
            data = conn.recv(1024)
            if not data: break
            conn.sendall(data)
```

Echo client example
-------------------

```python
import socket

with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as s:
    s.connect(('127.0.0.1', 2001))
    s.sendall(b'Hello, world')
    data = s.recv(1024)
print('Received', repr(data))
```
